## HTTP(HyperText Transfer Protocol)

  - 인터넷 상에서 클라이언트와 서버가 데이터를 주고 받을 때 쓰는 통신 규약 (프로토콜)

  - 80번 포트를 사용한다. -> 80번 포트에서 요청을 기다림 -> 클라이언트는 80포트로 요청을 보낸다.
  

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbkdJ4Q%2FbtqK6AXLEtC%2FjBZzMuJBWzdLYmqILo5Ri1%2Fimg.png" />

 - HTTP는 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다.
 - HTTP는 상태를 가지고 있지 않는 Stateless 프로토콜이며 Method, Path, Version, Headers, Body로 구성

<br>

HTTP는 텍스트 교환이므로, 누군가 네트워크에서 신호를 가로채면 내용이 노출되는 보안 이슈가 존재한다.

이런 보안 문제를 해결해주는 프로토콜이 **'HTTPS'**

<br>

#### HTTP의 보안 취약점

1. **도청이 가능하다**

- 평문으로 통신하기 때문에 도청이 가능하다
- 이를 해결하기 위해서 통신자체를암호화(HTTPS)하거나 데이터를 암호화 하는 방법등이 있다
- 데이터를 암호화 하는 경우 수신측에서는 보호화 과정이 필요하다

2. **위장이 가능하다**

- 통신 상대를 확인하지 않기 깨문에 위장된 상대와 통신할 수 있다
- HTTPS는 CA 인증서를 통해 인증된 상대와 통신이 가능하다

3. **변조가 가능하다**

- 완전성을 보장하지 않기 때문에 변조가 가능하다
- HTTPS는 메세지 인증 코드(MAC), 전자 서명등을 통해 변조를 방지 한다

<br>

## HTTPS(HyperText Transfer Protocol Secure)

  인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약

HTTPS는 텍스트를 암호화한다. (공개키 암호화 방식으로!) 

* HTTPS는 443포트를 사용한다.

* 네트워크 상에서 중간에 제3자가 정보를 볼 수 없도록 암호화를 지원한다.

* 대칭키 암호화
    - 클라이언트와 서버가 동일한 키를 사용해 암호화/복호화를 진행한다.
    - 키가 노출되면 매우 위험하지만 연산 속도가 빠름

* 비대칭키 암호화 (SSL 암호화 통신에 사용)
    - 1개의 쌍으로 구성된 공개키와 개인키를 암호화/복호화 하는데 사용한다.
    - 키가 노출되어도 비교적 안전하지만 연산 속도가 느리다.

## 비대칭키 암호화

비대칭 키 암호화는 공개키/개인키 암호화 방식을 이용해 데이터를 암호화하고 있다.
* 공개키 : 모두에게 공개가능한 키
* 개인키 : 나만 가지고 알고 있어야 하는 키

암호화를 공개키로 하느냐 개인키로 하느냐에 따라 얻는 효과가 다른데, 공개키와 개인키로 암호화하면 각각 다음과 같은 효과를 얻을 수 있다.

* 공개키 암호화 : 공개키로 암호화하면 개인키로만 복호화 할 수 있다 -> 개인키는 나만 가지고 있으므로, 나만 볼 수 있다.

* 개인키 암호화 : 개인키로 암호화하면 공개키로만 복호화할 수 있다 -> 공개키는 모두에게 공개되어 있으므로 내가 인증한 정보임을 알려 신뢰성을 보장할 수 있다.

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FOKcog%2FbtqK71fM8a4%2Fg1HmcDOR7MVRRz7pSKKJWk%2Fimg.png"/>

<br>

<br>


## HTTPS 통신 흐름

1. 애플리케이션 서버(A)를 만드는 기업은 HTTPS를 적용하기 위해 공개키와 개인키를 만든다.

2. 신뢰할 수 있는 CA 기업을 선택하고, 그 기업에게 내 공개키 관리를 부탁하며 계약을 한다.

**_CA란?_** : Certificate Authority로, 공개키를 저장해주는 신뢰성이 검증된 민간기업

3. 계약 완료된 CA 기업은 해당 기업의 이름, A서버 공개키, 공개키 암호화 방법을 담은 인증서를 만들고, 해당 인증서를 CA 기업의 개인키로 암호화해서 A서버에게 제공한다.

4. A서버는 암호화된 인증서를 갖게 되었다. 이제 A서버는 A서버의 공개키로 암호화된 HTTPS 요청이 아닌 요청이 오면, 이 암호화된 인증서를 클라이언트에게 건내준다.

5. 클라이언트가 `main.html` 파일을 달라고 A서버에 요청했다고 가정하자. HTTPS 요청이 아니기 때문에 CA기업이 A서버의 정보를 CA 기업의 개인키로 암호화한 인증서를 받게 된다.

CA 기업의 공개키는 브라우저가 이미 알고있다. (세계적으로 신뢰할 수 있는 기업으로 등록되어 있기 때문에, 브라우저가 인증서를 탐색하여 해독이 가능한 것)

6. 브라우저는 해독한 뒤 A서버의 공개키를 얻게 되었다.

7. 클라이언트가 A서버와 HandShaking 과정에서 주고받은 난수를 조합하여 pre-master-secret-key 를 생성한 뒤, A서버의 공개키로 해당 대칭키를 암호화하여 서버로 보냅니다.

8. A서버는 암호화된 대칭키를 자신의 개인키로 복호화 하여 클라이언트와 동일한 대칭키(master-secret-key)를 획득합니다.

9. 클라이언트, 서버는 각각 pre-master-secret-key를 master-secret-key으로 만듭니다.

10. master-secret-key 를 통해 session-key를 생성하고 이를 이용하여 대칭키 방식으로 통신합니다.

11. 각 통신이 종료될 때마다 session-key를 파기합니다.

<br>

HTTPS도 무조건 안전한 것은 아니다. (신뢰받는 CA 기업이 아닌 자체 인증서 발급한 경우 등)

이때는 HTTPS지만 브라우저에서 `주의 요함`, `안전하지 않은 사이트`와 같은 알림으로 주의 받게 된다.

<br>